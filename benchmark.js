// Generated by CoffeeScript 1.2.1-pre
(function() {
  var abs, calledBy, compute, counter, cycle, distribution, divisors, floor, freeDefine, freeExports, freeRequire, getAllKeys, getDescriptor, has, hasOwnProperty, isExtensible, max, min, noArgumentsClass, noCharByIndex, noCharByOwnIndex, pow, propertyIsEnumerable, run, setDescriptor, sqrt, timer, toString, uid, window;

  (function(window, undefined_) {
    var Benchmark, Deferred, Event, Suite, abort, abortSuite, add, addListener, applet, call, clock, clone, cloneSuite, compare, concat, createFunction, deepClone, each, emit, extend, filter, filterSuite, forEach, forOwn, forProps, formatNumber, getCriticalValue, getFirstArgument, getMean, getSource, hasKey, indexOf, insert, interpolate, invoke, isArguments, isClassOf, isHostType, isObject, isStringable, join, map, methodize, noop, pluck, reduce, removeAllListeners, removeListener, req, reset, resetSuite, resolve, reverse, runScript, runSuite, setOptions, shift, slice, splice, timer, toInteger, toStringBench, unshift;
    Benchmark = function(name, fn, options) {
      var me;
      me = this;
      if (me && me.constructor !== Benchmark) {
        return new Benchmark(name, fn, options);
      }
      if (isClassOf(name, "Object")) {
        options = name;
      } else if (isClassOf(name, "Function")) {
        options = fn;
        fn = name;
      } else if (isClassOf(fn, "Object")) {
        options = fn;
        fn = null;
        me.name = name;
      } else {
        me.name = name;
      }
      setOptions(me, options);
      me.id || (me.id = ++counter);
      !(me.fn != null) && (me.fn = fn);
      me.stats = extend({}, me.stats);
      return me.times = extend({}, me.times);
    };
    Deferred = function(bench) {
      var me;
      me = this;
      if (me && me.constructor !== Deferred) return new Deferred(bench);
      me.benchmark = bench;
      return clock(me);
    };
    Event = function(type) {
      var me;
      me = this;
      if (me && me.constructor !== Event) {
        return new Event(type);
      } else {
        if (type instanceof Event) {
          return type;
        } else {
          return extend(me, (typeof type === "string" ? {
            type: type
          } : type));
        }
      }
    };
    Suite = function(name, options) {
      var me;
      me = this;
      if (me && me.constructor !== Suite) return new Suite(name, options);
      if (isClassOf(name, "Object")) {
        options = name;
      } else {
        me.name = name;
      }
      return setOptions(me, options);
    };
    concat = function() {
      var index, j, k, l, length, result, value;
      value = void 0;
      j = -1;
      length = arguments.length;
      result = slice.call(this);
      index = result.length;
      while (++j < length) {
        value = arguments[j];
        if (isClassOf(value, "Array")) {
          k = 0;
          l = value.length;
          while (k < l) {
            if (k in value) result[index] = value[k];
            k++;
            index++;
          }
        } else {
          result[index] = value;
        }
      }
      return result;
    };
    insert = function(start, deleteCount, elements) {
      var deleteEnd, elementCount, index, length, object, result, tail;
      deleteEnd = start + deleteCount;
      elementCount = (elements ? elements.length : 0);
      index = start - 1;
      length = start + elementCount;
      object = this;
      result = [];
      tail = slice.call(object, deleteEnd);
      while (++index < deleteEnd) {
        if (index in object) {
          result[index - start] = object[index];
          delete object[index];
        }
      }
      index = start - 1;
      while (++index < length) {
        object[index] = elements[index - start];
      }
      start = index--;
      length = (object.length >>> 0) - deleteCount + elementCount;
      while (++index < length) {
        if ((index - start) in tail) {
          object[index] = tail[index - start];
        } else {
          delete object[index];
        }
      }
      deleteCount = (deleteCount > elementCount ? deleteCount - elementCount : 0);
      while (deleteCount--) {
        delete object[length + deleteCount];
      }
      object.length = length;
      return result;
    };
    reverse = function() {
      var index, length, middle, object, upperIndex, value;
      upperIndex = void 0;
      value = void 0;
      index = -1;
      object = Object(this);
      length = object.length >>> 0;
      middle = floor(length / 2);
      if (length > 1) {
        while (++index < middle) {
          upperIndex = length - index - 1;
          value = (upperIndex in object ? object[upperIndex] : uid);
          if (index in object) {
            object[upperIndex] = object[index];
          } else {
            delete object[upperIndex];
          }
          if (value !== uid) {
            object[index] = value;
          } else {
            delete object[index];
          }
        }
      }
      return object;
    };
    shift = function() {
      return insert.call(this, 0, 1)[0];
    };
    slice = function(start, end) {
      var index, length, object, result;
      index = -1;
      object = Object(this);
      length = object.length >>> 0;
      result = [];
      start = toInteger(start);
      start = (start < 0 ? max(length + start, 0) : min(start, length));
      start--;
      end = (!(end != null) ? length : toInteger(end));
      end = (end < 0 ? max(length + end, 0) : min(end, length));
      if ((function() {
        var _results;
        _results = [];
        while ((++index, ++start) < end) {
          _results.push(start in object);
        }
        return _results;
      })()) {
        result[index] = object[start];
      }
      return result;
    };
    splice = function(start, deleteCount) {
      var length, object;
      object = Object(this);
      length = object.length >>> 0;
      start = toInteger(start);
      start = (start < 0 ? max(length + start, 0) : min(start, length));
      deleteCount = min(max(toInteger(deleteCount), 0), length - start);
      return insert.call(object, start, deleteCount, slice.call(arguments, 2));
    };
    toInteger = function(value) {
      value = +value;
      if (value === 0 || !isFinite(value)) {
        return value || 0;
      } else {
        return value - (value % 1);
      }
    };
    unshift = function() {
      var object;
      object = Object(this);
      insert.call(object, 0, 0, arguments);
      return object.length;
    };
    call = function(options) {
      var fn;
      options || (options = {});
      fn = options.fn;
      return (!options.async && fn || function() {
        var bench, ids, index;
        bench = options.benchmark;
        ids = bench._timerIds || (bench._timerIds = []);
        index = ids.length;
        return ids.push(setTimeout(function() {
          ids.splice(index, 1);
          ids.length || delete bench._timerIds;
          return fn();
        }, bench.delay * 1e3));
      })();
    };
    createFunction = function() {
      createFunction = function(args, body) {
        var anchor, prop;
        anchor = (freeDefine ? define.amd : Benchmark);
        prop = uid + "createFunction";
        runScript((freeDefine ? "define.amd." : "Benchmark.") + prop + "=function(" + args + "){" + body + "}");
        return [anchor[prop], delete anchor[prop]][0];
      };
      createFunction = (has.browser && (createFunction("", "return\"" + uid + "\"") || noop)() === uid ? createFunction : Function);
      return createFunction.apply(null, arguments);
    };
    forProps = function() {
      var forArgs, forShadowed, shadowed, skipSeen;
      forShadowed = void 0;
      skipSeen = void 0;
      forArgs = true;
      shadowed = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
      (function(enumFlag, key) {
        var Klass;
        Klass = function() {
          return this.valueOf = 0;
        };
        Klass.prototype.valueOf = 0;
        for (key in new Klass) {
          enumFlag += (key === "valueOf" ? 1 : 0);
        }
        for (key in arguments) {
          key === "0" && (forArgs = false);
        }
        skipSeen = enumFlag === 2;
        return forShadowed = !enumFlag;
      })(0);
      forProps = function(object, callback, options) {
        var allFlag, ctor, done, fn, index, iteratee, key, keys, length, ownFlag, result, seen, skipCtor, skipProto, thisArg, which;
        options || (options = {});
        ctor = void 0;
        key = void 0;
        keys = void 0;
        skipCtor = void 0;
        done = !object;
        result = [object, object = Object(object)][0];
        which = options.which;
        allFlag = which === "all";
        fn = callback;
        index = -1;
        iteratee = object;
        length = object.length;
        ownFlag = allFlag || which === "own";
        seen = {};
        skipProto = isClassOf(object, "Function");
        thisArg = options.bind;
        object = Object(object);
        if (thisArg !== undefined) {
          callback = function(value, key, object) {
            return fn.call(thisArg, value, key, object);
          };
        }
        if (allFlag && has.getAllKeys) {
          index = 0;
          keys = getAllKeys(object);
          length = keys.length;
          while (index < length) {
            key = keys[index];
            if (callback(object[key], key, object) === false) break;
            index++;
          }
        } else {
          for (key in object) {
            if (done = !(skipProto && key === "prototype") && !(skipSeen && (hasKey(seen, key) || !(seen[key] = true))) && (!ownFlag || ownFlag && hasKey(object, key)) && callback(object[key], key, object) === false) {
              break;
            }
          }
          if ((function() {
            var _results;
            if (!done && (forArgs && isArguments(object) || (noCharByIndex || noCharByOwnIndex) && isClassOf(object, "String") && (iteratee = (noCharByIndex ? object.split("") : object)))) {
              _results = [];
              while (++index < length) {
                _results.push(done = callback(iteratee[index], String(index), object) === false);
              }
              return _results;
            }
          })()) {
            break;
          }
          if (!done && forShadowed) {
            ctor = object.constructor;
            skipCtor = ctor && ctor.prototype.and(ctor.prototype.constructor === ctor);
            index = 0;
            while (index < 7) {
              key = shadowed[index];
              if (!(skipCtor && key === "constructor") && hasKey(object, key) && callback(object[key], key, object) === false) {
                break;
              }
              index++;
            }
          }
        }
        return result;
      };
      return forProps.apply(null, arguments);
    };
    getCriticalValue = function(df) {
      return distribution[Math.round(df) || 1] || distribution.infinity;
    };
    getFirstArgument = function(fn, altName) {
      return (!hasKey(fn, "toString") && (/^[\s(]*function[^(]*\(([^\s,)]+)/.exec(fn) || 0)[1]) || altName || "";
    };
    getMean = function(sample) {
      return reduce(sample, function(sum, x) {
        return sum + x;
      }) / sample.length || 0;
    };
    getSource = function(fn, altSource) {
      var result;
      result = altSource;
      if (isStringable(fn)) {
        result = String(fn);
      } else {
        if (has.decompilation) {
          result = (/^[^{]+\{([\s\S]*)}\s*$/.exec(fn) || 0)[1];
        }
      }
      return (result || "").replace(/^\s+|\s+$/g, "");
    };
    isArguments = function() {
      isArguments = function(value) {
        return toString.call(value) === "[object Arguments]";
      };
      if (noArgumentsClass) {
        isArguments = function(value) {
          return hasKey(value, "callee") && !(propertyIsEnumerable && propertyIsEnumerable.call(value, "callee"));
        };
      }
      return isArguments(arguments[0]);
    };
    isClassOf = function(value, name) {
      return (value != null) && toString.call(value) === "[object " + name + "]";
    };
    isHostType = function(object, property) {
      var type;
      type = (object != null ? typeof object[property] : "number");
      return !/^(?:boolean|number|string|undefined)$/.test(type) && (type === "object" ? !!object[property] : true);
    };
    isObject = function(value) {
      var ctor, result;
      ctor = void 0;
      result = !!value && toString.call(value) === "[object Object]";
      if (result && noArgumentsClass) result = !isArguments(value);
      if (result) {
        ctor = value.constructor;
        if (result = isClassOf(ctor, "Function") && ctor instanceof ctor) {
          forProps(value, function(subValue, subKey) {
            return result = subKey;
          });
          result = result === true || hasKey(value, result);
        }
      }
      return result;
    };
    isStringable = function(value) {
      return hasKey(value, "toString") || isClassOf(value, "String");
    };
    methodize = function(fn) {
      return function() {
        var args;
        args = [this];
        args.push.apply(args, arguments);
        return fn.apply(null, args);
      };
    };
    noop = function() {};
    req = function(id) {
      try {
        return freeExports && freeRequire(id);
      } catch (_error) {}
      return null;
    };
    runScript = function(code) {
      var anchor, parent, prefix, prop, script, sibling;
      anchor = (freeDefine ? define.amd : Benchmark);
      script = document.createElement("script");
      sibling = document.getElementsByTagName("script")[0];
      parent = sibling.parentNode;
      prop = uid + "runScript";
      prefix = "(" + (freeDefine ? "define.amd." : "Benchmark.") + prop + "||function(){})();";
      try {
        script.appendChild(document.createTextNode(prefix + code));
        anchor[prop] = function() {
          return parent.removeChild(script);
        };
      } catch (e) {
        parent = parent.cloneNode(false);
        sibling = null;
        script.text = code;
      }
      parent.insertBefore(script, sibling);
      return delete anchor[prop];
    };
    setOptions = function(bench, options) {
      options = extend({}, bench.constructor.options, options);
      return bench.options = forOwn(options, function(value, key) {
        if (value != null) {
          if (/^on[A-Z]/.test(key)) {
            return forEach(key.split(" "), function(key) {
              return bench.on(key.slice(2).toLowerCase(), value);
            });
          } else {
            return bench[key] = deepClone(value);
          }
        }
      });
    };
    resolve = function() {
      var bench, me;
      me = this;
      bench = me.benchmark;
      if (++me.cycles < bench.count) {
        return (bench._host || bench).compiled.call(me, timer);
      } else {
        timer.stop(me);
        return call({
          async: true,
          benchmark: bench,
          fn: function() {
            return cycle({
              benchmark: bench,
              deferred: me
            });
          }
        });
      }
    };
    deepClone = function(value) {
      var Marker, accessor, circular, clone, ctor, data, descriptor, extensible, getMarkerKey, index, key, length, marked, markerKey, parent, propCallback, queue, result, source, subIndex, unmarked;
      Marker = function(object) {
        return this.raw = object;
      };
      getMarkerKey = function(object) {
        var result;
        result = uid;
        while (object[result] && object[result].constructor !== Marker) {
          result += 1;
        }
        return result;
      };
      propCallback = function(subValue, subKey) {
        if (subValue && subValue.constructor === Marker) return;
        if (subValue === Object(subValue)) {
          return queue[queue.length++] = {
            key: subKey,
            parent: clone,
            source: value
          };
        } else {
          return clone[subKey] = subValue;
        }
      };
      accessor = void 0;
      circular = void 0;
      clone = void 0;
      ctor = void 0;
      descriptor = void 0;
      extensible = void 0;
      key = void 0;
      length = void 0;
      markerKey = void 0;
      parent = void 0;
      result = void 0;
      source = void 0;
      subIndex = void 0;
      data = {
        value: value
      };
      index = 0;
      marked = [];
      queue = {
        length: 0
      };
      unmarked = [];
      while (true) {
        key = data.key;
        parent = data.parent;
        source = data.source;
        clone = value = (source ? source[key] : data.value);
        accessor = circular = descriptor = false;
        if (value === Object(value)) {
          if (isClassOf(value.deepClone, "Function")) {
            clone = value.deepClone();
          } else {
            ctor = value.constructor;
            switch (toString.call(value)) {
              case "[object Array]":
                clone = new ctor(value.length);
                break;
              case "[object Boolean]":
                clone = new ctor(value === true);
                break;
              case "[object Date]":
                clone = new ctor(+value);
                break;
              case "[object Object]":
                isObject(value) && (clone = new ctor);
                break;
              case "[object Number]":
              case "[object String]":
                clone = new ctor(value);
                break;
              case "[object RegExp]":
                clone = ctor(value.source, (value.global ? "g" : "") + (value.ignoreCase ? "i" : "") + (value.multiline ? "m" : ""));
            }
          }
          if (clone && clone !== value && !(descriptor = source && has.descriptors && getDescriptor(source, key), accessor = descriptor && (descriptor.get || descriptor.set))) {
            if (extensible = isExtensible(value)) {
              markerKey = getMarkerKey(value);
              if (value[markerKey]) circular = clone = value[markerKey].raw;
            } else {
              subIndex = 0;
              length = unmarked.length;
              while (subIndex < length) {
                data = unmarked[subIndex];
                if (data.object === value) {
                  circular = clone = data.clone;
                  break;
                }
                subIndex++;
              }
            }
            if (!circular) {
              if (extensible) {
                value[markerKey] = new Marker(clone);
                marked.push({
                  key: markerKey,
                  object: value
                });
              } else {
                unmarked.push({
                  clone: clone,
                  object: value
                });
              }
              forProps(value, propCallback, {
                which: "all"
              });
            }
          }
        }
        if (parent) {
          if (accessor || (descriptor && !(descriptor.configurable && descriptor.enumerable && descriptor.writable))) {
            descriptor.value && (descriptor.value = clone);
            setDescriptor(parent, key, descriptor);
          } else {
            parent[key] = clone;
          }
        } else {
          result = clone;
        }
        if (!(data = queue[index++])) break;
      }
      index = 0;
      length = marked.length;
      while (index < length) {
        data = marked[index];
        delete data.object[data.key];
        index++;
      }
      return result;
    };
    each = function(object, callback, thisArg) {
      var fn, index, isConvertable, isSnapshot, isSplittable, length, origObject, result;
      fn = callback;
      index = -1;
      result = [object, object = Object(object)][0];
      origObject = object;
      length = object.length;
      isSnapshot = !!(object.snapshotItem && (length = object.snapshotLength));
      isSplittable = (noCharByIndex || noCharByOwnIndex) && isClassOf(object, "String");
      isConvertable = isSnapshot || isSplittable || "item" in object;
      if (length === length >>> 0) {
        if (isConvertable) {
          callback = function(value, index) {
            return fn.call(this, value, index, origObject);
          };
          if (isSplittable) {
            object = object.split("");
          } else {
            object = [];
            while (++index < length) {
              object[index] = (isSnapshot ? result.snapshotItem(index) : result[index]);
            }
          }
        }
        forEach(object, callback, thisArg);
      } else {
        forOwn(object, callback, thisArg);
      }
      return result;
    };
    extend = function(destination, source) {
      destination = [destination, delete arguments[0]][0];
      forEach(arguments, function(source) {
        return forProps(source, function(value, key) {
          return destination[key] = value;
        });
      });
      return destination;
    };
    filter = function(array, callback, thisArg) {
      var result;
      result = void 0;
      if (callback === "successful") {
        callback = function(bench) {
          return bench.cycles && isFinite(bench.hz);
        };
      } else if (callback === "fastest" || callback === "slowest") {
        result = filter(array, "successful").sort(function(a, b) {
          a = a.stats;
          b = b.stats;
          return (a.mean + a.moe > b.mean + b.moe ? 1 : -1) * (callback === "fastest" ? 1 : -1);
        });
        result = filter(result, function(bench) {
          return result[0].compare(bench) === 0;
        });
      }
      return result || reduce(array, function(result, value, index) {
        if (callback.call(thisArg, value, index, array)) {
          result.push(value);
          return result;
        } else {
          return result;
        }
      }, []);
    };
    forEach = function(array, callback, thisArg) {
      var fn, index, length;
      fn = callback;
      index = -1;
      length = (array = Object(array)).length >>> 0;
      if (thisArg !== undefined) {
        callback = function(value, index, array) {
          return fn.call(thisArg, value, index, array);
        };
      }
      if ((function() {
        var _results;
        _results = [];
        while (++index < length) {
          _results.push(index in array && callback(array[index], index, array) === false);
        }
        return _results;
      })()) {
        break;
      }
      return array;
    };
    forOwn = function(object, callback, thisArg) {
      return forProps(object, callback, {
        bind: thisArg,
        which: "own"
      });
    };
    formatNumber = function(number) {
      number = String(number).split(".");
      return number[0].replace(/(?=(?:\d{3})+$)(?!\b)/g, ",") + (number[1] ? "." + number[1] : "");
    };
    hasKey = function() {
      hasKey = function(object, key) {
        var parent;
        parent = (object != null) && (object.constructor || Object).prototype;
        return !!parent && key in Object(object) && !(key in parent && object[key] === parent[key]);
      };
      if (isClassOf(hasOwnProperty, "Function")) {
        hasKey = function(object, key) {
          return (object != null) && hasOwnProperty.call(object, key);
        };
      } else if ({}.__proto__ === Object.prototype) {
        hasKey = function(object, key) {
          var result;
          result = false;
          if (object != null) {
            object = Object(object);
            object.__proto__ = [object.__proto__, object.__proto__ = null, result = key in object][0];
          }
          return result;
        };
      }
      return hasKey.apply(this, arguments);
    };
    indexOf = function(array, value, fromIndex) {
      var index, length;
      index = toInteger(fromIndex);
      length = (array = Object(array)).length >>> 0;
      index = (index < 0 ? max(0, length + index) : index) - 1;
      if ((function() {
        var _results;
        _results = [];
        while (++index < length) {
          _results.push(index in array && value === array[index]);
        }
        return _results;
      })()) {
        return index;
      }
      return -1;
    };
    interpolate = function(string, object) {
      forOwn(object, function(value, key) {
        return string = string.replace(RegExp("#\\{" + key + "\\}", "g"), value);
      });
      return string;
    };
    invoke = function(benches, name) {
      var args, bench, execute, getNext, index, isAsync, isRun, isSync, options, queued, raiseIndex, result;
      isAsync = function(object) {
        var async;
        async = args[0] && args[0].async;
        return isRun(object) && (!(async != null) ? object.options.async : async) && has.timeout;
      };
      isRun = function(object) {
        return Object(object).constructor === Benchmark && name === "run";
      };
      isSync = function(object) {
        return !isAsync(object) && !(isRun(object) && object.defer);
      };
      execute = function() {
        var listeners, sync;
        listeners = void 0;
        sync = isSync(bench);
        if (!sync) {
          bench.on("complete", getNext);
          listeners = bench.events.complete;
          listeners.splice(0, 0, listeners.pop());
        }
        result[index] = (isClassOf(bench && bench[name], "Function") ? bench[name].apply(bench, args) : undefined);
        return sync && getNext();
      };
      getNext = function() {
        var bench, last, sync;
        last = bench;
        sync = isSync(last);
        if (!sync) {
          last.removeListener("complete", getNext);
          last.emit("complete");
        }
        if (options.onCycle.call(benches, Event("cycle"), last) !== false && raiseIndex() !== false) {
          bench = (queued ? benches[0] : result[index]);
          if (!isSync(bench)) {
            call({
              async: isAsync(bench),
              benchmark: bench,
              fn: execute
            });
          } else if (!sync) {
            while (execute()) {
              continue;
            }
          } else {
            return true;
          }
        } else {
          options.onComplete.call(benches, Event("complete"), last);
        }
        return false;
      };
      raiseIndex = function() {
        var index, length;
        length = result.length;
        if (queued) {
          while (true) {
            ++index > 0 && shift.call(benches);
            if (!((length = benches.length) && ("0" in benches))) break;
          }
        } else {
          while (++index < length && (!(index in result))) {
            continue;
          }
        }
        if ((queued ? length : index < length)) {
          return index;
        } else {
          return index = false;
        }
      };
      args = void 0;
      bench = void 0;
      queued = void 0;
      index = -1;
      options = {
        onStart: noop,
        onCycle: noop,
        onComplete: noop
      };
      result = map(benches, function(bench) {
        return bench;
      });
      if (isClassOf(name, "String")) {
        args = slice.call(arguments, 2);
      } else {
        options = extend(options, name);
        name = options.name;
        args = (isClassOf(args = ("args" in options ? options.args : []), "Array") ? args : [args]);
        queued = options.queued;
      }
      if (raiseIndex() !== false) {
        bench = result[index];
        options.onStart.call(benches, Event("start"), bench);
        if (benches.aborted && benches.constructor === Suite && name === "run") {
          options.onCycle.call(benches, Event("cycle"), bench);
          options.onComplete.call(benches, Event("complete"), bench);
        } else {
          if (isAsync(bench)) {
            call({
              async: true,
              benchmark: bench,
              fn: execute
            });
          } else {
            while (execute()) {
              continue;
            }
          }
        }
      }
      return result;
    };
    join = function(object, separator1, separator2) {
      var arrayLike, length, result;
      result = [];
      length = (object = Object(object)).length;
      arrayLike = length === length >>> 0;
      separator2 || (separator2 = ": ");
      each(object, function(value, key) {
        return result.push((arrayLike ? value : key + separator2 + value));
      });
      return result.join(separator1 || ",");
    };
    map = function(array, callback, thisArg) {
      return reduce(array, (function(result, value, index) {
        result[index] = callback.call(thisArg, value, index, array);
        return result;
      }), Array(Object(array).length >>> 0));
    };
    pluck = function(array, property) {
      return map(array, function(object) {
        if (!(object != null)) {
          return undefined;
        } else {
          return object[property];
        }
      });
    };
    reduce = function(array, callback, accumulator) {
      var noaccum;
      noaccum = arguments.length < 3;
      forEach(array, function(value, index) {
        return accumulator = (noaccum ? (noaccum = 0, value) : callback(accumulator, value, index, array));
      });
      return accumulator;
    };
    abortSuite = function() {
      var me;
      me = this;
      if (me.running) {
        calledBy.abortSuite = true;
        me.reset();
        delete calledBy.abortSuite;
        me.aborted = true;
        !calledBy.resetSuite && invoke(me, "abort");
        me.emit("abort");
      }
      return me;
    };
    add = function(name, fn, options) {
      var bench, me;
      me = this;
      bench = Benchmark(name, fn, options);
      me.push(bench);
      me.emit("add", bench);
      return me;
    };
    cloneSuite = function(options) {
      var me, result;
      me = this;
      result = new me.constructor(extend({}, me.options, options));
      forOwn(me, function(value, key) {
        if (!hasKey(result, key)) {
          return result[key] = (value && isClassOf(value.clone, "Function") ? value.clone() : deepClone(value));
        }
      });
      return result;
    };
    filterSuite = function(callback) {
      var me, result;
      me = this;
      result = new me.constructor;
      result.push.apply(result, filter(me, callback));
      return result;
    };
    resetSuite = function() {
      var me, notAborting;
      me = this;
      notAborting = !calledBy.abortSuite;
      if (me.running && notAborting) {
        calledBy.resetSuite = true;
        me.abort();
        delete calledBy.resetSuite;
        me.aborted = false;
      } else if (me.aborted !== false || me.running !== false) {
        me.aborted = me.running = false;
        notAborting && invoke(me, "reset");
        me.emit("reset");
      }
      return me;
    };
    runSuite = function(options) {
      var benches, me;
      me = this;
      benches = [];
      me.reset();
      me.running = true;
      options || (options = {});
      invoke(me, {
        name: "run",
        args: options,
        queued: options.queued,
        onStart: function(event, bench) {
          return me.emit("start", bench);
        },
        onCycle: function(event, bench) {
          if (bench.error) {
            me.emit("error", bench);
          } else {
            if (bench.cycles) benches.push(bench);
          }
          return !me.aborted && me.emit("cycle", bench);
        },
        onComplete: function(event, bench) {
          me.running = false;
          return me.emit("complete", bench);
        }
      });
      return me;
    };
    addListener = function(type, listener) {
      var events, me;
      me = this;
      events = me.events || (me.events = {});
      forEach(type.split(" "), function(type) {
        return (events[type] || (events[type] = [])).push(listener);
      });
      return me;
    };
    emit = function(type) {
      var args, event, events, listeners, me, result;
      me = this;
      event = Event(type);
      args = (arguments[0] = event, arguments);
      events = me.events;
      listeners = events && events[event.type] || [];
      result = true;
      forEach(listeners.slice(), function(listener) {
        return result = listener.apply(me, args) !== false;
      });
      return result;
    };
    removeListener = function(type, listener) {
      var events, me;
      me = this;
      events = me.events;
      forEach(type.split(" "), function(type) {
        var index, listeners;
        listeners = events && events[type] || [];
        index = indexOf(listeners, listener);
        if (index > -1) return listeners.splice(index, 1);
      });
      return me;
    };
    removeAllListeners = function(type) {
      var events, me;
      me = this;
      events = me.events;
      forEach((type ? type.split(" ") : events), function(type) {
        return (events && events[type] || []).length = 0;
      });
      return me;
    };
    abort = function() {
      var me;
      me = this;
      if (me.running) {
        if (has.timeout) {
          forEach(me._timerIds || [], clearTimeout);
          delete me._timerIds;
        }
        calledBy.abort = true;
        me.reset();
        delete calledBy.abort;
        me.aborted = true;
        me.emit("abort");
      }
      return me;
    };
    clone = function(options) {
      var me, result;
      me = this;
      result = new me.constructor(extend({}, me, options));
      result.options = extend({}, me.options, options);
      forOwn(me, function(value, key) {
        if (!hasKey(result, key)) return result[key] = deepClone(value);
      });
      return result;
    };
    compare = function(other) {
      var a, b, df, near, pooled, tstat;
      a = this.stats;
      b = other.stats;
      df = a.size + b.size - 2;
      pooled = ((a.size - 1) * a.variance) + ((b.size - 1) * b.variance) / df;
      tstat = (a.mean - b.mean) / sqrt(pooled * (1 / a.size + 1 / b.size));
      near = abs(1 - a.mean / b.mean) < 0.055 && a.rme < 3 && b.rme < 3;
      if (!near && abs(tstat) > getCriticalValue(df)) {
        if (tstat > 0) {
          return -1;
        } else {
          return 1;
        }
      } else {
        return 0;
      }
    };
    reset = function() {
      var changed, me, pair, pairs, source;
      changed = void 0;
      pair = void 0;
      me = this;
      source = extend({}, me.constructor.prototype, me.options);
      pairs = [[source, me]];
      if (me.running && !calledBy.abort) {
        me.abort();
        me.aborted = source.aborted;
      } else {
        while ((pair = pairs.pop())) {
          forOwn(pair[0], function(value, key) {
            var other;
            other = pair[1][key];
            if (value && isClassOf(value, "Object")) {
              return pairs.push([value, other]);
            } else if (value !== other && !(!(value != null) || isClassOf(value, "Function"))) {
              pair[1][key] = value;
              return changed = true;
            }
          });
        }
        if (changed) me.emit("reset");
      }
      return me;
    };
    toStringBench = function() {
      var error, hz, id, me, pm, result, size, stats;
      me = this;
      error = me.error;
      hz = me.hz;
      id = me.id;
      stats = me.stats;
      size = stats.size;
      pm = (has.java ? "+/-" : "Â±");
      result = me.name || (typeof id === "number" ? "<Test #" + id + ">" : id);
      if (error) {
        result += ": " + join(error);
      } else {
        result += " x " + formatNumber(hz.toFixed((hz < 100 ? 2 : 0))) + " ops/sec " + pm + stats.rme.toFixed(2) + "% (" + size + " run" + (size === 1 ? "" : "s") + " sampled)";
      }
      return result;
    };
    clock = function() {
      var applet, getRes, options, preprocess, template, timers;
      getRes = function(unit) {
        var begin, count, divisor, measured, ns, sample;
        measured = void 0;
        begin = void 0;
        count = 30;
        divisor = 1e3;
        ns = timer.ns;
        sample = [];
        while (count--) {
          if (unit === "us") {
            divisor = 1e6;
            if (ns.stop) {
              ns.start();
              while (!(measured = ns.microseconds())) {
                continue;
              }
            } else {
              begin = timer.ns();
              while (!(measured = ns() - begin)) {
                continue;
              }
            }
          } else if (unit === "ns") {
            divisor = 1e9;
            begin = ns.nanoTime();
            while (!(measured = ns.nanoTime() - begin)) {
              continue;
            }
          } else {
            begin = new ns;
            while (!(measured = new ns - begin)) {
              continue;
            }
          }
          if (measured > 0) {
            sample.push(measured);
          } else {
            sample.push(Infinity);
            break;
          }
        }
        return getMean(sample) / divisor;
      };
      preprocess = function(code) {
        return interpolate(code, template).replace(/\$/g, /\d+/.exec(uid));
      };
      applet = void 0;
      options = Benchmark.options;
      template = {
        begin: "s$=new n$",
        end: "r$=(new n$-s$)/1e3",
        uid: uid
      };
      return timers = [
        {
          ns: timer.ns,
          res: max(0.0015, getRes("ms")),
          unit: "ms"
        }
      ];
    };
    clock = function(bench) {
      var compiled, count, decompilable, deferred, fn, fnArg, host, id, isEmpty, name, ns, result, source, stringable;
      deferred = bench instanceof Deferred && [bench, bench = bench.benchmark][0];
      host = bench._host || bench;
      fn = host.fn;
      fnArg = (deferred ? getFirstArgument(fn, "deferred") : "");
      stringable = isStringable(fn);
      decompilable = has.decompilation || stringable;
      source = {
        setup: getSource(host.setup, preprocess("m$.setup()")),
        fn: getSource(fn, preprocess("f$(" + fnArg + ")")),
        fnArg: fnArg,
        teardown: getSource(host.teardown, preprocess("m$.teardown()"))
      };
      compiled = host.compiled;
      count = host.count = bench.count;
      id = host.id;
      isEmpty = !(source.fn || stringable);
      name = host.name || (typeof id === "number" ? "<Test #" + id + ">" : id);
      ns = timer.ns;
      result = 0;
      bench.minTime = host.minTime || (host.minTime = host.options.minTime = options.minTime);
      if (applet) {
        try {
          ns.nanoTime();
        } catch (e) {
          ns = timer.ns = new applet.Packages.nano;
        }
      }
      if (!compiled) {
        compiled = host.compiled = createFunction(preprocess("t$"), interpolate(preprocess((deferred ? ("var d$=this," + fnArg + "=d$,r$=d$.resolve,m$=(m$=d$.benchmark)._host||m$,f$=m$.fn;") + "if(!d$.cycles){d$.resolve=function(){d$.resolve=r$;r$.call(d$);" + ("if(d$.cycles==m$.count){" + teardown + "\n}};" + setup + "\nt$.start(d$);}" + fn + "\nreturn{}") : ("var r$,s$,m$=this,f$=m$.fn,i$=m$.count,n$=t$.ns;" + setup + "\n" + begin + ";") + ("while(i$--){" + fn + "\n}" + end + ";" + teardown + "\nreturn{elapsed:r$,uid:\"" + uid + "\"}"))), source));
        try {
          if (isEmpty) {
            throw new Error("The test, " + name + ", is empty. This may be the result of dead code removal.");
          } else if (!deferred) {
            host.count = 1;
            compiled = (compiled.call(host, timer) || {}).uid === uid && compiled;
            host.count = count;
          }
        } catch (e) {
          compiled = false;
          bench.error = e || new Error(String(e));
          host.count = count;
        }
        if (decompilable && !compiled && !deferred && !isEmpty) {
          compiled = createFunction(preprocess("t$"), interpolate(preprocess((bench.error && !stringable ? "var r$,s$,m$=this,f$=m$.fn,i$=m$.count" : "function f$(){" + fn + "\n}var r$,s$,i$=this.count") + (",n$=t$.ns;" + setup + "\n" + begin + ";while(i$--){f$()}" + end + ";" + teardown + "\nreturn{elapsed:r$}")), source));
          try {
            host.count = 1;
            compiled.call(host, timer);
            host.compiled = compiled;
            host.count = count;
            delete bench.error;
          } catch (e) {
            host.count = count;
            if (!bench.error) {
              host.compiled = compiled;
              bench.error = e || new Error(String(e));
            }
          }
        }
      }
      if (!bench.error) result = compiled.call(deferred || host, timer).elapsed;
      return result;
    };
    each(window.document && document.applets || [], function(element) {
      var applet;
      return !(timer.ns = applet = "nanoTime" in element && element);
    });
    try {
      if (typeof timer.ns.nanoTime() === "number") {
        timers.push({
          ns: timer.ns,
          res: getRes("ns"),
          unit: "ns"
        });
      }
    } catch (_error) {}
    try {
      if (timer.ns = new (window.chrome || window.chromium).Interval) {
        timers.push({
          ns: timer.ns,
          res: getRes("us"),
          unit: "us"
        });
      }
    } catch (_error) {}
    if (timer.ns = (req("microtime") || {
      now: 0
    }).now) {
      timers.push({
        ns: timer.ns,
        res: getRes("us"),
        unit: "us"
      });
    }
    timer = reduce(timers, function(timer, other) {
      if (other.res < timer.res) {
        return other;
      } else {
        return timer;
      }
    });
    if (timer.unit !== "ns" && applet) {
      applet = (applet.parentNode.removeChild(applet), null);
    }
    if (timer.res === Infinity) {
      throw new Error("Benchmark.js was unable to find a working timer.");
    }
    if (timer.unit === "ns") {
      extend(template, {
        begin: "s$=n$.nanoTime()",
        end: "r$=(n$.nanoTime()-s$)/1e9"
      });
    } else if (timer.unit === "us") {
      extend(template, (timer.ns.stop ? {
        begin: "s$=n$.start()",
        end: "r$=n$.microseconds()/1e6"
      } : {
        begin: "s$=n$()",
        end: "r$=(n$()-s$)/1e6"
      }));
    }
    timer.start = createFunction(preprocess("o$"), preprocess("var n$=this.ns," + begin + ";o$.timeStamp=s$"));
    timer.stop = createFunction(preprocess("o$"), preprocess("var n$=this.ns,s$=o$.timeStamp," + end + ";o$.elapsed=r$"));
    options.minTime || (options.minTime = max(timer.res / 2 / 0.01, 0.05));
    return clock.apply(null, arguments);
  }, compute = function(options) {
    var async, bench, elapsed, enqueue, evaluate, initCount, queue, sample, update;
    enqueue = function(count) {
      var _results;
      _results = [];
      while (count--) {
        _results.push(queue.push(bench.clone({
          _host: bench,
          events: {
            start: [update],
            cycle: [update]
          }
        })));
      }
      return _results;
    };
    update = function(event) {
      var clone, cycles, type;
      clone = this;
      cycles = clone.cycles;
      type = event.type;
      if (bench.running) {
        if (type === "cycle") {
          if (clone.error) {
            bench.abort();
            bench.error = clone.error;
            bench.emit("error");
          } else {
            bench.hz = clone.hz;
            bench.initCount = clone.initCount;
            bench.times.period = clone.times.period;
            if (cycles > bench.cycles) bench.cycles = cycles;
          }
          return bench.emit(type);
        } else {
          return clone.count = bench.initCount;
        }
      } else {
        if (bench.aborted) return clone.abort();
      }
    };
    evaluate = function(event, clone) {
      var done, maxedOut, mean, moe, now, rme, sd, sem, size, times, varOf, variance;
      mean = void 0;
      moe = void 0;
      rme = void 0;
      sd = void 0;
      sem = void 0;
      variance = void 0;
      now = +(new Date);
      times = bench.times;
      done = bench.aborted;
      maxedOut = (elapsed += now - clone.times.timeStamp) / 1e3 > bench.maxTime;
      size = sample.push(clone.times.period);
      varOf = function(sum, x) {
        return sum + pow(x - mean, 2);
      };
      if (done || clone.hz === Infinity) {
        maxedOut = !(size = sample.length = queue.length = 0);
      }
      if (!done) {
        mean = getMean(sample);
        variance = reduce(sample, varOf, 0) / (size - 1) || 0;
        sd = sqrt(variance);
        sem = sd / sqrt(size);
        moe = sem * getCriticalValue(size - 1);
        rme = (moe / mean) * 100 || 0;
        extend(bench.stats, {
          moe: moe,
          rme: rme,
          sem: sem,
          deviation: sd,
          mean: mean,
          size: size,
          variance: variance
        });
        if (maxedOut) {
          done = true;
          bench.running = false;
          bench.initCount = initCount;
          times.elapsed = (now - times.timeStamp) / 1e3;
        }
        if (bench.hz !== Infinity) {
          times.period = mean;
          times.cycle = mean * bench.count;
          bench.hz = 1 / mean;
        }
      }
      if (queue.length < 2 && !maxedOut) enqueue(1);
      return !done;
    };
    options || (options = {});
    async = options.async;
    bench = options.benchmark;
    elapsed = 0;
    queue = [];
    sample = [];
    initCount = bench.initCount;
    enqueue(bench.minSamples);
    return invoke(queue, {
      name: "run",
      args: {
        async: async
      },
      queued: true,
      onCycle: evaluate,
      onComplete: function() {
        return bench.emit("complete");
      }
    });
  }, cycle = function(options) {
    var async, bench, clocked, count, deferred, divisor, minTime, period, times;
    options || (options = {});
    clocked = void 0;
    divisor = void 0;
    minTime = void 0;
    period = void 0;
    async = options.async;
    bench = options.benchmark;
    count = bench.count;
    deferred = options.deferred;
    times = bench.times;
    if (bench.running) {
      bench.cycles++;
      clocked = (deferred ? deferred.elapsed : clock(bench));
      minTime = bench.minTime;
      if (bench.error) {
        bench.abort();
        bench.emit("error");
      }
    }
    if (bench.running) {
      times.cycle = clocked;
      period = times.period = clocked / count;
      bench.hz = 1 / period;
      bench.running = clocked < minTime;
      bench.initCount = count;
      if (bench.running) {
        if (!clocked && ((divisor = divisors[bench.cycles]) != null)) {
          count = floor(4e6 / divisor);
        }
        if (count <= bench.count) count += Math.ceil((minTime - clocked) / period);
        bench.running = count !== Infinity;
      }
    }
    if (bench.emit("cycle") === false) bench.abort();
    if (bench.running) {
      bench.count = count;
      if (deferred) {
        return (bench._host || bench).compiled.call(deferred, timer);
      } else {
        return call({
          async: async,
          benchmark: bench,
          fn: function() {
            return cycle({
              async: async,
              benchmark: bench
            });
          }
        });
      }
    } else {
      if (has.browser) runScript(uid + "=1;delete " + uid);
      return bench.emit("complete");
    }
  }, run = function(options) {
    var async, me;
    me = this;
    async = (!((async = options && options.async) != null) ? me.async : async) && has.timeout;
    me.running = false;
    me.reset();
    me.running = true;
    me.count = me.initCount;
    me.times.timeStamp = +(new Date);
    me.emit("start");
    if (me._host) {
      if (me.defer) {
        Deferred(me);
      } else {
        cycle({
          async: async,
          benchmark: me
        });
      }
    } else {
      compute({
        async: async,
        benchmark: me
      });
    }
    return me;
  }, freeDefine = typeof define === "function" && typeof define.amd === "object" && define.amd && define, freeExports = typeof exports === "object" && exports && (typeof global === "object" && global && global === global.global && (window = global), exports), freeRequire = typeof require === "function" && require, counter = 0, getAllKeys = Object.getOwnPropertyNames, getDescriptor = Object.getOwnPropertyDescriptor, hasOwnProperty = {}.hasOwnProperty, isExtensible = Object.isExtensible || function() {
    return true;
  }, propertyIsEnumerable = {}.propertyIsEnumerable, setDescriptor = Object.defineProperty, toString = {}.toString, uid = "uid" + (+(new Date)), calledBy = {}, divisors = {
    1: 4096,
    2: 512,
    3: 64,
    4: 8,
    5: 0
  }, distribution = {
    1: 12.706,
    2: 4.303,
    3: 3.182,
    4: 2.776,
    5: 2.571,
    6: 2.447,
    7: 2.365,
    8: 2.306,
    9: 2.262,
    10: 2.228,
    11: 2.201,
    12: 2.179,
    13: 2.16,
    14: 2.145,
    15: 2.131,
    16: 2.12,
    17: 2.11,
    18: 2.101,
    19: 2.093,
    20: 2.086,
    21: 2.08,
    22: 2.074,
    23: 2.069,
    24: 2.064,
    25: 2.06,
    26: 2.056,
    27: 2.052,
    28: 2.048,
    29: 2.045,
    30: 2.042,
    infinity: 1.96
  }, has = {
    air: isClassOf(window.runtime, "ScriptBridgingProxyObject"),
    argumentsClass: isClassOf(arguments, "Arguments"),
    browser: isHostType(window, "document") && isHostType(window, "navigator"),
    charByIndex: ("x"[0] + Object("x")[0]) === "xx",
    charByOwnIndex: "x"[0] === "x" && hasKey("x", "0"),
    decompilation: !!((function() {
      try {
        return Function("return (" + (function(x) {
          return {
            x: "" + (1 + x) + "",
            y: 0
          };
        }) + ")")()(0).x === "1";
      } catch (_error) {}
    })()),
    descriptors: !!((function() {
      var o;
      try {
        o = {};
        return (setDescriptor(o, o, o), "value" in getDescriptor(o, o));
      } catch (_error) {}
    })()),
    getAllKeys: !!((function() {
      try {
        return /\bvalueOf\b/.test(getAllKeys(Object.prototype));
      } catch (_error) {}
    })()),
    java: isClassOf(window.java, "JavaPackage"),
    timeout: isHostType(window, "setTimeout") && isHostType(window, "clearTimeout")
  }, timer = {
    ns: Date,
    start: null,
    stop: null
  }, noArgumentsClass = !has.argumentsClass, noCharByIndex = !has.charByIndex, noCharByOwnIndex = !has.charByOwnIndex, abs = Math.abs, floor = Math.floor, max = Math.max, min = Math.min, pow = Math.pow, sqrt = Math.sqrt, extend(Benchmark, {
    options: {
      async: false,
      defer: false,
      delay: 0.005,
      id: null,
      initCount: 1,
      maxTime: 5,
      minSamples: 5,
      minTime: 0,
      name: null
    },
    platform: req("platform") || window.platform || {
      description: window.navigator && navigator.userAgent || null,
      layout: null,
      product: null,
      name: null,
      manufacturer: null,
      os: null,
      prerelease: null,
      version: null,
      toString: function() {
        return this.description || "";
      }
    },
    version: "0.3.0",
    deepClone: deepClone,
    each: each,
    extend: extend,
    filter: filter,
    forEach: forEach,
    forOwn: forOwn,
    formatNumber: formatNumber,
    hasKey: (hasKey(Benchmark, ""), hasKey),
    indexOf: indexOf,
    interpolate: interpolate,
    invoke: invoke,
    join: join,
    map: map,
    pluck: pluck,
    reduce: reduce
  }), extend(Benchmark.prototype, {
    count: 0,
    cycles: 0,
    hz: 0,
    compiled: null,
    error: null,
    fn: null,
    aborted: false,
    running: false,
    on: addListener,
    setup: noop,
    teardown: noop,
    stats: {
      moe: 0,
      rme: 0,
      sem: 0,
      deviation: 0,
      mean: 0,
      size: 0,
      variance: 0
    },
    times: {
      cycle: 0,
      elapsed: 0,
      period: 0,
      timeStamp: 0
    },
    abort: abort,
    addListener: addListener,
    clone: clone,
    compare: compare,
    emit: emit,
    removeAllListeners: removeAllListeners,
    removeListener: removeListener,
    reset: reset,
    run: run,
    toString: toStringBench
  }), Suite.options = {
    name: null
  }, extend(Suite.prototype, {
    length: 0,
    aborted: false,
    running: false,
    forEach: methodize(forEach),
    indexOf: methodize(indexOf),
    invoke: methodize(invoke),
    join: [].join,
    map: methodize(map),
    pluck: methodize(pluck),
    pop: [].pop,
    push: [].push,
    sort: [].sort,
    reduce: methodize(reduce),
    abort: abortSuite,
    add: add,
    addListener: addListener,
    clone: cloneSuite,
    emit: emit,
    filter: filterSuite,
    on: addListener,
    removeAllListeners: removeAllListeners,
    removeListener: removeListener,
    reset: resetSuite,
    run: runSuite,
    concat: concat,
    reverse: reverse,
    shift: shift,
    slice: slice,
    splice: splice,
    unshift: unshift
  }), extend(Deferred.prototype, {
    benchmark: null,
    cycles: 0,
    elapsed: 0,
    timeStamp: 0,
    resolve: resolve
  }), Event.prototype.type = "", extend(Benchmark, {
    Deferred: Deferred,
    Event: Event,
    Suite: Suite
  }), freeExports ? typeof module === "object" && module && module.exports === freeExports ? (module.exports = Benchmark).Benchmark = Benchmark : freeExports.Benchmark = Benchmark : freeDefine ? define("benchmark", function() {
    return Benchmark;
  }) : window["Benchmark"] = Benchmark, has.air ? clock({
    fn: noop,
    count: 1,
    options: {}
  }) : void 0)(this);

}).call(this);
